# This workflow creates a new GitHub Release when a tag is pushed.
# It is a generic, configuration-driven, three-stage workflow.
# Stage 1: 'validate' - Runs validation scripts.
# Stage 2: 'approve' - Waits for manual approval if configured.
# Stage 3: 'build-and-publish' - Runs final validation, builds, and creates the release.

name: Release Publisher

on:
    push:
        tags:
            - "v*" # Trigger on tags like v1.0, v1.2.3

permissions:
    contents: write

jobs:
    validate:
        name: Validate
        runs-on: ubuntu-latest
        outputs:
            manual_approval: ${{ steps.check_approval.outputs.manual_approval }}
        steps:
            - name: Check out repository
              uses: actions/checkout@v4

            - name: Set up Python for TOML parsing
              uses: actions/setup-python@v5
              with:
                  python-version: "3.x"

            - name: Install parsers
              run: python -m pip install toml PyYAML

            - name: Run Validation Steps
              id: check_approval
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  CONFIG_DATA=$(python -c "import toml; import json; print(json.dumps(toml.load('.github/release.toml')))")

                  # Run simple steps
                  STEPS=$(echo "$CONFIG_DATA" | python -c "import sys, json; data=json.load(sys.stdin); print('\n'.join(data.get('validate', {}).get('steps', [])))")
                  if [ -n "$STEPS" ]; then
                    echo "Executing validation steps:"
                    echo "$STEPS"
                    for step in $STEPS; do
                      echo "--- Running $step ---"
                      bash ".github/release.d/$step"
                      echo "--- Finished $step ---"
                    done
                  fi

                  # Run matrix steps
                  MATRIX_STEPS_JSON=$(echo "$CONFIG_DATA" | python -c "import sys, json; data=json.load(sys.stdin); print(json.dumps(data.get('validate', {}).get('matrix_steps', [])))")
                  MATRIX_LENGTH=$(echo "$MATRIX_STEPS_JSON" | python -c "import sys, json; print(len(json.load(sys.stdin)))")

                  for i in $(seq 0 $(($MATRIX_LENGTH - 1))); do
                    WORKFLOW=$(echo "$MATRIX_STEPS_JSON" | python -c "import sys, json; print(json.load(sys.stdin)[$i]['workflow'])")
                    PARAM_NAME=$(echo "$MATRIX_STEPS_JSON" | python -c "import sys, json; print(json.load(sys.stdin)[$i]['parameter_name'])")
                    MATRIX_VALUES=$(echo "$MATRIX_STEPS_JSON" | python -c "import sys, json; print('\n'.join(json.load(sys.stdin)[$i]['matrix']))")
                    
                    echo "Triggering matrix workflow: $WORKFLOW"
                    for value in $MATRIX_VALUES; do
                      echo "  with $PARAM_NAME = $value"
                      gh workflow run "$WORKFLOW" --ref "${{ github.ref }}" -f "$PARAM_NAME=$value"
                    done
                  done

                  APPROVAL=$(echo "$CONFIG_DATA" | python -c "import sys, json; data=json.load(sys.stdin); print(str(data.get('workflow', {}).get('manual_approval', False)).lower())")
                  echo "manual_approval=$APPROVAL" >> $GITHUB_OUTPUT

    approve:
        name: Approve Release
        runs-on: ubuntu-latest
        needs: validate
        if: needs.validate.outputs.manual_approval == 'true'
        environment: release
        steps:
            - name: Wait for approval
              run: echo "Manual approval step. This job will pause until approved."

    build-and-publish:
        name: Build and Publish
        runs-on: ubuntu-latest
        needs: [validate, approve]
        if: always() && (needs.validate.outputs.manual_approval == 'false' || needs.approve.result == 'success')
        steps:
            - name: Check out repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Set up Python
              uses: actions/setup-python@v5
              with:
                  python-version: "3.x"

            - name: Install parsers
              run: python -m pip install toml PyYAML

            - name: Execute final validation and build scripts
              id: run_scripts
              run: |
                  FINAL_VALIDATION_STEP=$(python -c "import toml; print(toml.load('.github/release.toml')['build']['final_validation_step'])")
                  BUILD_STEPS=$(python -c "import toml; print('\n'.join(toml.load('.github/release.toml')['build']['steps']))")
                  ASSET_DIR=$(python -c "import toml; print(toml.load('.github/release.toml')['assets']['source_directory'])")

                  echo "--- Running Final Validation: $FINAL_VALIDATION_STEP ---"
                  bash ".github/release.d/$FINAL_VALIDATION_STEP"
                  echo "--- Finished Final Validation ---"

                  echo "Executing build steps:"
                  echo "$BUILD_STEPS"
                  for step in $BUILD_STEPS; do
                    echo "--- Running $step ---"
                    bash ".github/release.d/$step"
                    echo "--- Finished $step ---"
                  done

                  echo "asset_dir=$ASSET_DIR" >> $GITHUB_OUTPUT

            - name: Generate Changelog
              id: generate_changelog
              run: |
                  CHANGELOG_TEMPLATE=$(python -c "import toml; print(toml.load('.github/release.toml')['changelog']['template'])")
                  PREVIOUS_TAG=$(git describe --tags --abbrev=0 `git rev-list --tags --skip=1 --max-count=1` || echo "")

                  if [ -z "$PREVIOUS_TAG" ]; then
                    COMMITS=$(git log ${{ github.ref_name }} --pretty=format:'* %s (`%h`)')
                    URL="https://github.com/${{ github.repository }}/commits/${{ github.ref_name }}"
                  else
                    COMMITS=$(git log $PREVIOUS_TAG...${{ github.ref_name }} --pretty=format:'* %s (`%h`)')
                    URL="https://github.com/${{ github.repository }}/compare/$PREVIOUS_TAG...${{ github.ref_name }}"
                  fi

                  # Robustly build the changelog instead of using a single sed substitution
                  CHANGELOG_HEADER=$(echo "$CHANGELOG_TEMPLATE" | sed -n '/\${COMMITS}/q;p')
                  CHANGELOG_FOOTER=$(echo "$CHANGELOG_TEMPLATE" | sed '1,/\${COMMITS}/d')

                  # Substitute variables in header and footer
                  CHANGELOG_HEADER=$(echo "$CHANGELOG_HEADER" | sed -e "s|\${REPO_NAME}|${{ github.event.repository.name }}|g" -e "s|\${TAG}|${{ github.ref_name }}|g")
                  CHANGELOG_FOOTER=$(echo "$CHANGELOG_FOOTER" | sed -e "s|\${URL}|$URL|g")

                  # Build the final changelog file
                  echo "$CHANGELOG_HEADER" > changelog.md
                  echo "$COMMITS" >> changelog.md
                  echo "$CHANGELOG_FOOTER" >> changelog.md

                  echo "changelog_path=changelog.md" >> $GITHUB_OUTPUT

            - name: Create GitHub Release
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  ASSET_DIR="${{ steps.run_scripts.outputs.asset_dir }}"
                  NOTES_FILE="${{ steps.generate_changelog.outputs.changelog_path }}"

                  # Construct the command
                  cmd="gh release create ${{ github.ref_name }} --title \"${{ github.event.repository.name }} ${{ github.ref_name }}\" --notes-file \"$NOTES_FILE\""

                  # Append assets if they exist
                  if [ -d "$ASSET_DIR" ] && [ "$(ls -A "$ASSET_DIR")" ]; then
                    echo "Assets found in $ASSET_DIR. Appending to release command."
                    cmd="$cmd \"$ASSET_DIR\"/*"
                  else
                    echo "No assets found in $ASSET_DIR."
                  fi

                  # Execute the command
                  eval $cmd
