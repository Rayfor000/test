# This workflow creates a new GitHub Release when a tag is pushed.
# It is a generic, configuration-driven, three-stage workflow.
# Stage 1: 'validate' - Runs validation scripts.
# Stage 2: 'approve' - Waits for manual approval if configured.
# Stage 3: 'build-and-publish' - Runs final validation, builds, and creates the release.

name: Release Publisher

on:
    push:
        tags:
            - "v*" # Trigger on tags like v1.0, v1.2.3

permissions:
    contents: write

jobs:
    validate:
        name: Validate
        runs-on: ubuntu-latest
        outputs:
            manual_approval: ${{ steps.check_approval.outputs.manual_approval }}
        steps:
            - name: Check out repository
              uses: actions/checkout@v4

            - name: Set up Python for TOML parsing
              uses: actions/setup-python@v5
              with:
                  python-version: "3.x"

            - name: Install parsers
              run: python -m pip install toml PyYAML

            - name: Read Config and Run Validation
              id: check_approval
              run: |
                  CONFIG_DATA=$(python -c "import toml; import json; print(json.dumps(toml.load('.github/release.toml')))")

                  run_step() {
                    local step_name=$1
                    local step_path=".github/release.d/$step_name"
                    echo "--- Running $step_name ---"
                    if [[ "$step_name" == *.sh ]]; then
                      bash "$step_path"
                    elif [[ "$step_name" == *.yml || "$step_name" == *.yaml ]]; then
                      # Check for simple 'run' key first
                      if python -c "import yaml; f=open('$step_path'); d=yaml.safe_load(f); exit(0 if 'run' in d else 1)"; then
                        COMMAND_TO_RUN=$(python -c "import yaml; f=open('$step_path'); d=yaml.safe_load(f); print(d['run']); f.close()")
                        echo "Executing from simple YAML: $COMMAND_TO_RUN"
                        eval "$COMMAND_TO_RUN"
                      # Check for complex job structure
                      elif python -c "import yaml; f=open('$step_path'); d=yaml.safe_load(f); exit(0 if 'jobs' in d and 'build' in d['jobs'] and 'steps' in d['jobs']['build'] else 1)"; then
                        echo "Executing steps from complex YAML workflow..."
                        python -c "import yaml; import os; f=open('$step_path'); d=yaml.safe_load(f); [os.system(step['run']) for step in d['jobs']['build']['steps'] if 'run' in step]; f.close()"
                      else
                        echo "Unsupported YAML structure in $step_name" >&2
                        exit 1
                      fi
                    else
                      echo "Unsupported step type: $step_name" >&2
                      exit 1
                    fi
                    echo "--- Finished $step_name ---"
                  }

                  STEPS=$(echo "$CONFIG_DATA" | python -c "import sys, json; print('\n'.join(json.load(sys.stdin)['validate']['steps']))")
                  echo "Executing validation steps:"
                  echo "$STEPS"
                  for step in $STEPS; do
                    run_step "$step"
                  done

                  APPROVAL=$(echo "$CONFIG_DATA" | python -c "import sys, json; print(str(json.load(sys.stdin)['workflow']['manual_approval']).lower())")
                  echo "manual_approval=$APPROVAL" >> $GITHUB_OUTPUT

    approve:
        name: Approve Release
        runs-on: ubuntu-latest
        needs: validate
        if: needs.validate.outputs.manual_approval == 'true'
        environment: release
        steps:
            - name: Wait for approval
              run: echo "Manual approval step. This job will pause until approved."

    build-and-publish:
        name: Build and Publish
        runs-on: ubuntu-latest
        needs: [validate, approve]
        if: always() && (needs.validate.outputs.manual_approval == 'false' || needs.approve.result == 'success')
        steps:
            - name: Check out repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Set up Python
              uses: actions/setup-python@v5
              with:
                  python-version: "3.x"

            - name: Install parsers
              run: python -m pip install toml PyYAML

            - name: Execute final validation and build scripts
              id: run_scripts
              run: |
                  CONFIG_DATA=$(python -c "import toml; import json; print(json.dumps(toml.load('.github/release.toml')))")

                  FINAL_VALIDATION_STEP=$(echo "$CONFIG_DATA" | python -c "import sys, json; print(json.load(sys.stdin)['build']['final_validation_step'])")
                  BUILD_STEPS=$(echo "$CONFIG_DATA" | python -c "import sys, json; print('\n'.join(json.load(sys.stdin)['build']['steps']))")
                  ASSET_DIR=$(echo "$CONFIG_DATA" | python -c "import sys, json; print(json.load(sys.stdin)['assets']['source_directory'])")

                  run_step() {
                    local step_name=$1
                    local step_path=".github/release.d/$step_name"
                    echo "--- Running $step_name ---"
                    if [[ "$step_name" == *.sh ]]; then
                      bash "$step_path"
                    elif [[ "$step_name" == *.yml || "$step_name" == *.yaml ]]; then
                      COMMAND_TO_RUN=$(python -c "import yaml; f=open('$step_path'); d=yaml.safe_load(f); print(d['run']); f.close()")
                      echo "Executing from YAML: $COMMAND_TO_RUN"
                      eval "$COMMAND_TO_RUN"
                    else
                      echo "Unsupported step type: $step_name" >&2
                      exit 1
                    fi
                    echo "--- Finished $step_name ---"
                  }

                  echo "--- Running Final Validation: $FINAL_VALIDATION_STEP ---"
                  run_step "$FINAL_VALIDATION_STEP"
                  echo "--- Finished Final Validation ---"

                  echo "Executing build steps:"
                  echo "$BUILD_STEPS"
                  for step in $BUILD_STEPS; do
                    run_step "$step"
                  done

                  echo "asset_dir=$ASSET_DIR" >> $GITHUB_OUTPUT

            - name: Generate Changelog
              id: generate_changelog
              run: |
                  CONFIG_DATA=$(python -c "import toml; import json; print(json.dumps(toml.load('.github/release.toml')))")
                  CHANGELOG_TEMPLATE=$(echo "$CONFIG_DATA" | python -c "import sys, json; print(json.load(sys.stdin)['changelog']['template'])")
                  REPO_URL=$(echo "$CONFIG_DATA" | python -c "import sys, json; print(json.load(sys.stdin)['github']['repository_url'])")
                  PREVIOUS_TAG=$(git describe --tags --abbrev=0 `git rev-list --tags --skip=1 --max-count=1` || echo "")

                  if [ -z "$PREVIOUS_TAG" ]; then
                    COMMITS=$(git log ${{ github.ref_name }} --pretty=format:'* %s (`%h`)')
                    URL="$REPO_URL/commits/${{ github.ref_name }}"
                  else
                    COMMITS=$(git log $PREVIOUS_TAG...${{ github.ref_name }} --pretty=format:'* %s (`%h`)')
                    URL="$REPO_URL/compare/$PREVIOUS_TAG...${{ github.ref_name }}"
                  fi

                  # Build the final changelog file
                  CHANGELOG_CONTENT=$(echo "$CHANGELOG_TEMPLATE" | sed "s|\${REPO_NAME}|${{ github.event.repository.name }}|g")
                  CHANGELOG_CONTENT=$(echo "$CHANGELOG_CONTENT" | sed "s|\${TAG}|${{ github.ref_name }}|g")
                  CHANGELOG_CONTENT=$(echo "$CHANGELOG_CONTENT" | sed "s|\${URL}|$URL|g")

                  # Use a temporary file to handle the multiline commits
                  echo "$COMMITS" > commits.tmp
                  CHANGELOG_CONTENT=$(sed -e "/\${COMMITS}/r commits.tmp" -e "/\${COMMITS}/d" <<< "$CHANGELOG_CONTENT")
                  rm commits.tmp

                  echo "$CHANGELOG_CONTENT" > changelog.md

                  echo "changelog_path=changelog.md" >> $GITHUB_OUTPUT

            - name: Create GitHub Release
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  ASSET_DIR="${{ steps.run_scripts.outputs.asset_dir }}"
                  NOTES_FILE="${{ steps.generate_changelog.outputs.changelog_path }}"

                  # Construct the command
                  cmd="gh release create ${{ github.ref_name }} --title \"${{ github.event.repository.name }} ${{ github.ref_name }}\" --notes-file \"$NOTES_FILE\""

                  # Append assets if they exist
                  if [ -d "$ASSET_DIR" ] && [ "$(ls -A "$ASSET_DIR")" ]; then
                    echo "Assets found in $ASSET_DIR. Appending to release command."
                    cmd="$cmd \"$ASSET_DIR\"/*"
                  else
                    echo "No assets found in $ASSET_DIR."
                  fi

                  # Execute the command
                  eval $cmd
