name: Release Publisher
on:
    workflow_dispatch:
        inputs:
            tag:
                description: "The tag to create the release for (e.g., v1.0.0)"
                required: true
            previous_tag:
                description: "The previous tag for changelog generation"
                required: true
permissions:
    contents: write
    id-token: write
jobs:
    parse_configs:
        name: Parse Configuration Files
        runs-on: ubuntu-latest
        outputs:
            # from release-manifest.toml
            check_matrix: ${{ steps.toml.outputs.check_matrix }}
            build_matrix: ${{ steps.toml.outputs.build_matrix }}
            skip_approval: ${{ steps.toml.outputs.release_skip_approval }}
            release_assets_include: ${{ steps.toml.outputs.release_assets_include }}
            release_assets_exclude: ${{ steps.toml.outputs.release_assets_exclude }}
            check_run_script: ${{ steps.toml.outputs.check_run_script }}
            check_cache_enable: ${{ steps.toml.outputs.check_features_cache_enable }}
            check_cache_path: ${{ steps.toml.outputs.check_features_cache_path }}
            check_cache_key_file: ${{ steps.toml.outputs.check_features_cache_key_file }}
            build_run_script: ${{ steps.toml.outputs.build_run_script }}
            build_cache_enable: ${{ steps.toml.outputs.build_features_cache_enable }}
            build_cache_path: ${{ steps.toml.outputs.build_features_cache_path }}
            build_cache_key_file: ${{ steps.toml.outputs.build_features_cache_key_file }}
        steps:
            - uses: actions/checkout@v5
              with:
                  fetch-depth: 0
            - name: Check if tag exists
              shell: bash
              run: |
                  if git rev-parse "refs/tags/${{ github.event.inputs.tag }}" >/dev/null 2>&1; then
                    echo "::error::Tag '${{ github.event.inputs.tag }}' already exists. Workflow will be terminated."
                    exit 1
                  fi
            - name: Set up Python
              uses: actions/setup-python@v6
              with:
                  python-version: "3.12"
            - name: Install Python dependencies
              run: pip install toml
            - name: Parse release-manifest.toml
              id: toml
              shell: python
              run: |
                  import json
                  import os
                  import toml
                  with open(".github/release-manifest.toml") as f:
                      data = toml.load(f)
                  def get_output_line(key, value):
                      if isinstance(value, bool):
                          value = str(value).lower()
                      return f"{key}={value}"
                  def set_multiline_output(f, key, value_list):
                      value = "\n".join(value_list)
                      delimiter = "GH_ACTIONS_EOF"
                      f.write(f"{key}<<{delimiter}\n")
                      f.write(f"{value}\n")
                      f.write(f"{delimiter}\n")
                  check_matrix = json.dumps(data["check"].get("matrix", {}))
                  build_matrix = json.dumps(data["build"].get("matrix", {}))
                  with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                      f.write(f"check_matrix={check_matrix}\n")
                      f.write(f"build_matrix={build_matrix}\n")
                      f.write(get_output_line("release_skip_approval", data["release"]["skip_approval"]) + "\n")
                      assets = data.get("release", {}).get("assets", {})
                      set_multiline_output(f, "release_assets_include", assets.get("include", []))
                      set_multiline_output(f, "release_assets_exclude", assets.get("exclude", []))
                      f.write(get_output_line("check_run_script", data["check"]["run_script"]) + "\n")
                      f.write(get_output_line("check_features_cache_enable", data["check"]["features"]["cache"]["enable"]) + "\n")
                      f.write(get_output_line("check_features_cache_path", data["check"]["features"]["cache"]["path"]) + "\n")
                      f.write(get_output_line("check_features_cache_key_file", data["check"]["features"]["cache"]["key_file"]) + "\n")
                      f.write(get_output_line("build_run_script", data["build"]["run_script"]) + "\n")
                      f.write(get_output_line("build_features_cache_enable", data["build"]["features"]["cache"]["enable"]) + "\n")
                      f.write(get_output_line("build_features_cache_path", data["build"]["features"]["cache"]["path"]) + "\n")
                      f.write(get_output_line("build_features_cache_key_file", data["build"]["features"]["cache"]["key_file"]) + "\n")
    check:
        needs: parse_configs
        name: Check & Test
        runs-on: ${{ matrix.os }}
        strategy:
            fail-fast: false
            matrix: ${{ fromJson(needs.parse_configs.outputs.check_matrix) }}
        steps:
            - uses: actions/checkout@v5
            - name: Cache dependencies
              if: needs.parse_configs.outputs.check_cache_enable == 'true'
              uses: actions/cache@v4
              with:
                  path: ${{ needs.parse_configs.outputs.check_cache_path }}
                  key: "${{ runner.os }}-pip-${{ hashFiles(needs.parse_configs.outputs.check_cache_key_file) }}"
            - name: Set up Python
              uses: actions/setup-python@v6
              with:
                  python-version: ${{ matrix.python-version }}
            - name: Make check script executable
              run: chmod +x ${{ needs.parse_configs.outputs.check_run_script }}
            - name: Run Check Script
              shell: bash
              run: ${{ needs.parse_configs.outputs.check_run_script }}
              env:
                  PYTHON_VERSION: ${{ matrix.python-version }}
                  RUNNER_OS: ${{ matrix.os }}
    approval:
        name: Approve for Release
        needs: [parse_configs, check]
        runs-on: ubuntu-latest
        environment: release
        steps:
            - name: Manual approval step
              if: needs.parse_configs.outputs.skip_approval == 'false'
              run: echo "Release approved. Proceeding to build."
    build:
        name: Build
        needs: [parse_configs, approval]
        if: needs.approval.result == 'success' || needs.approval.result == 'skipped'
        runs-on: ${{ matrix.os }}
        strategy:
            fail-fast: false
            matrix: ${{ fromJson(needs.parse_configs.outputs.build_matrix) }}
        steps:
            - uses: actions/checkout@v5
            - name: Cache dependencies
              if: needs.parse_configs.outputs.build_cache_enable == 'true'
              uses: actions/cache@v4
              with:
                  path: ${{ needs.parse_configs.outputs.build_cache_path }}
                  key: "${{ runner.os }}-pip-${{ hashFiles(needs.parse_configs.outputs.build_cache_key_file) }}"
            - name: Set up Python
              uses: actions/setup-python@v6
              with:
                  python-version: "3.12"
            - name: Make build script executable
              run: chmod +x ${{ needs.parse_configs.outputs.build_run_script }}
            - name: Run Build Script
              shell: bash
              run: ${{ needs.parse_configs.outputs.build_run_script }}
              env:
                  TARGET: ${{ matrix.target }}
            - name: Upload artifact
              uses: actions/upload-artifact@v4
              with:
                  name: build-artifact-${{ matrix.os }}-${{ matrix.target }}
                  path: |
                      dist/
    release:
        name: Create Release
        needs: [check, build, approval]
        if: needs.approval.result == 'success' || needs.approval.result == 'skipped'
        runs-on: ubuntu-latest
        steps:
            - uses: actions/checkout@v5
              with:
                  fetch-depth: 0
            - name: Set up Python
              uses: actions/setup-python@v6
              with:
                  python-version: "3.12"
            - name: Install dependencies
              run: pip install toml tomli
            - name: Download all artifacts
              uses: actions/download-artifact@v4
              with:
                  path: ./dist
            - name: Prepare Release Assets
              id: prepare_assets
              shell: python
              run: |
                  import os
                  import sys
                  from pathlib import Path
                  import tomli
                  def get_asset_patterns(manifest_path: Path) -> tuple[list[str], list[str]]:
                      if not manifest_path.is_file():
                          print(f"Error: Manifest file not found at '{manifest_path}'", file=sys.stderr)
                          sys.exit(1)
                      try:
                          with open(manifest_path, "rb") as f:
                              manifest = tomli.load(f)
                          release_config = manifest.get("release", {})
                          assets_config = release_config.get("assets", {})
                          include_patterns = assets_config.get("include", [])
                          exclude_patterns = assets_config.get("exclude", [])
                          if not isinstance(include_patterns, list) or not isinstance(exclude_patterns, list):
                              print("Error: 'release.assets.include' and 'release.assets.exclude' must be arrays of strings.", file=sys.stderr)
                              sys.exit(1)
                          return include_patterns, exclude_patterns
                      except tomli.TOMLDecodeError:
                          print(f"Error: Could not decode TOML file at '{manifest_path}'", file=sys.stderr)
                          sys.exit(1)
                      except Exception as e:
                          print(f"An unexpected error occurred: {e}", file=sys.stderr)
                          sys.exit(1)
                  def find_files(root_dir: Path, include_patterns: list[str], exclude_patterns: list[str]) -> list[str]:
                      final_files = set()
                      for pattern in include_patterns:
                          for path in root_dir.glob(f"**/{pattern}"):
                              if path.is_file():
                                  final_files.add(str(path))
                      excluded_files = set()
                      for pattern in exclude_patterns:
                          for path in root_dir.glob(f"**/{pattern}"):
                              if path.is_file():
                                  excluded_files.add(str(path))
                      return sorted(list(final_files - excluded_files))
                  def main():
                      manifest_path = Path(".github/release-manifest.toml")
                      include, exclude = get_asset_patterns(manifest_path)
                      workspace_dir = Path(os.getcwd())
                      final_asset_list = find_files(workspace_dir, include, exclude)
                      with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                          f.write("final_assets<<EOF\n")
                          f.write("\n".join(final_asset_list))
                          f.write("\nEOF\n")
                  main()
            - name: Generate Release Notes
              id: notes_generator
              shell: python
              run: |
                  # -*- coding: utf-8 -*-
                  import os
                  import subprocess
                  import sys
                  from datetime import datetime, timezone
                  from pathlib import Path
                  import toml
                  def get_env_var(name: str, required: bool = True, default: str = "") -> str:
                      """Gets an environment variable, exiting if required and not found."""
                      value = os.environ.get(name)
                      if required and not value:
                          print(f"Error: Missing required environment variable '{name}'", file=sys.stderr)
                          sys.exit(1)
                      return value if value is not None else default
                  def run_command(command: str) -> str:
                      """Runs a shell command and returns its stdout, or an empty string on error."""
                      try:
                          result = subprocess.run(
                              command,
                              shell=True,
                              check=True,
                              capture_output=True,
                              text=True,
                              encoding='utf-8'
                          )
                          return result.stdout.strip()
                      except subprocess.CalledProcessError as e:
                          print(f"Warning: Command '{command}' failed with error: {e.stderr.strip()}", file=sys.stderr)
                          return "" # Return empty string for robustness
                  def generate_changelog(previous_tag: str, current_tag: str) -> str:
                      """Generates a changelog from Git history between two tags."""
                      if not previous_tag or not current_tag:
                          return "Changelog generation skipped: missing previous or current tag."
                      command = f'git log {previous_tag}..{current_tag} --pretty=format:"- %s (%h)"'
                      return run_command(command)
                  def generate_assets_links(repo_full_name: str, tag: str, asset_files_str: str) -> str:
                      """Generates a Markdown-formatted list of links for release assets."""
                      if not asset_files_str:
                          return "No assets provided."
                      asset_files = asset_files_str.strip().split("\n")
                      links = []
                      for asset_file in asset_files:
                          if not asset_file:
                              continue
                          filename = Path(asset_file).name
                          link = f"- [{filename}](https://github.com/{repo_full_name}/releases/download/{tag}/{filename})"
                          links.append(link)
                      return "\n".join(links)
                  def main():
                      """Main function to generate and print release notes."""
                      try:
                          # --- 1. Read all inputs from environment variables ---
                          repo_full_name = get_env_var("GITHUB_REPOSITORY")
                          tag = get_env_var("INPUT_TAG")
                          previous_tag = get_env_var("INPUT_PREVIOUS_TAG")
                          asset_files = get_env_var("ASSET_FILES", required=False)
                          manifest_path_str = get_env_var("MANIFEST_PATH")
                          
                          manifest_path = Path(manifest_path_str)
                          if not manifest_path.is_file():
                              print(f"Error: Manifest file not found at '{manifest_path}'", file=sys.stderr)
                              sys.exit(1)
                          manifest = toml.load(manifest_path)
                          body_template = manifest.get("release", {}).get("body_template", "")
                          if not body_template:
                              print("Error: 'release.body_template' not found in manifest.", file=sys.stderr)
                              sys.exit(1)
                          # --- 2. Prepare placeholder values ---
                          owner, repo_name = repo_full_name.split('/', 1) if '/' in repo_full_name else (repo_full_name, "")
                          
                          release_date = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
                          changelog_content = generate_changelog(previous_tag, tag)
                          assets_links_content = generate_assets_links(repo_full_name, tag, asset_files)
                          
                          contributors_template = manifest.get("release", {}).get("contributors", {}).get("template", "")
                          contributors_content = contributors_template.replace("{{owner}}", owner).replace("{{repo_name}}", repo_name)
                          # --- 3. Render the template ---
                          replacements = {
                              "{{repo_name}}": repo_name,
                              "{{owner}}": owner,
                              "{{tag}}": tag,
                              "{{release_date}}": release_date,
                              "{{changelog}}": changelog_content,
                              "{{assets_links}}": assets_links_content,
                              "{{contributors}}": contributors_content,
                          }
                          body = body_template
                          for placeholder, value in replacements.items():
                              body = body.replace(placeholder, value)
                          # --- 4. Set GitHub Action output ---
                          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                              f.write("body<<EOF\n")
                              f.write(body)
                              f.write("\nEOF\n")
                      except (KeyError, FileNotFoundError, toml.TomlDecodeError, Exception) as e:
                          print(f"An unexpected error occurred: {e}", file=sys.stderr)
                          sys.exit(1)
                  if __name__ == "__main__":
                      main()
              env:
                  GITHUB_REPOSITORY: ${{ github.repository }}
                  INPUT_TAG: ${{ github.event.inputs.tag }}
                  INPUT_PREVIOUS_TAG: ${{ github.event.inputs.previous_tag }}
                  ASSET_FILES: ${{ steps.prepare_assets.outputs.final_assets }}
                  MANIFEST_PATH: ".github/release-manifest.toml"
            - name: Create Release
              uses: softprops/action-gh-release@v1
              with:
                  tag_name: ${{ github.event.inputs.tag }}
                  body: ${{ steps.notes_generator.outputs.body }}
                  files: ${{ steps.prepare_assets.outputs.final_assets }}
