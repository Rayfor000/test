name: Release Publisher
on:
    workflow_dispatch:
        inputs:
            tag:
                description: "The tag to create the release for (e.g., v1.0.0)"
                required: true
permissions:
    contents: write
    id-token: write
jobs:
    parse_configs:
        name: Parse Configuration Files
        runs-on: ubuntu-latest
        outputs:
            # from actions-config.yml
            check_matrix: ${{ steps.yaml.outputs.check_matrix }}
            build_targets: ${{ steps.yaml.outputs.build_targets }}
            # from release-manifest.toml
            trigger_tag_pattern: ${{ steps.toml.outputs.trigger_tag_pattern }}
            skip_approval: ${{ steps.toml.outputs.release_skip_approval }}
            release_assets_include: ${{ steps.toml.outputs.release_assets_include }}
            release_assets_exclude: ${{ steps.toml.outputs.release_assets_exclude }}
            check_runs_on: ${{ steps.toml.outputs.check_runs-on }}
            check_run_script: ${{ steps.toml.outputs.check_run_script }}
            check_cache_enable: ${{ steps.toml.outputs.check_features_cache_enable }}
            check_cache_path: ${{ steps.toml.outputs.check_features_cache_path }}
            check_cache_key_file: ${{ steps.toml.outputs.check_features_cache_key_file }}
            build_runs_on: ${{ steps.toml.outputs.build_runs-on }}
            build_run_script: ${{ steps.toml.outputs.build_run_script }}
            build_cache_enable: ${{ steps.toml.outputs.build_features_cache_enable }}
            build_cache_path: ${{ steps.toml.outputs.build_features_cache_path }}
            build_cache_key_file: ${{ steps.toml.outputs.build_features_cache_key_file }}
        steps:
            - uses: actions/checkout@v5
            - name: Check if tag exists
              shell: bash
              run: |
                  if git rev-parse "refs/tags/${{ github.event.inputs.tag }}" >/dev/null 2>&1; then
                    echo "Error: Tag '${{ github.event.inputs.tag }}' already exists."
                    exit 1
                  fi
            - name: Set up Python
              uses: actions/setup-python@v6
              with:
                  python-version: "3.12"
            - name: Install Python dependencies
              run: pip install PyYAML toml
            - name: Parse actions-config.yml
              id: yaml
              shell: python
              run: |
                  import json
                  import os
                  import yaml
                  with open(".github/actions-config.yml") as f:
                      data = yaml.safe_load(f)
                  check_matrix = json.dumps(data["check"]["matrix"])
                  build_targets = " ".join(data["build"]["matrix"]["target"])
                  with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                      f.write(f"check_matrix={check_matrix}\n")
                      f.write(f"build_targets={build_targets}\n")
            - name: Parse release-manifest.toml
              id: toml
              shell: python
              run: |
                  import os
                  import toml
                  with open(".github/release-manifest.toml") as f:
                      data = toml.load(f)
                  def get_output_line(key, value):
                      if isinstance(value, bool):
                          value = str(value).lower()
                      return f"{key}={value}"
                  def set_multiline_output(f, key, value_list):
                      value = "\n".join(value_list)
                      delimiter = "GH_ACTIONS_EOF"
                      f.write(f"{key}<<{delimiter}\n")
                      f.write(f"{value}\n")
                      f.write(f"{delimiter}\n")
                  with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                      f.write(get_output_line("trigger_tag_pattern", data["trigger"]["tag_pattern"]) + "\n")
                      f.write(get_output_line("release_skip_approval", data["release"]["skip_approval"]) + "\n")
                      assets = data.get("release", {}).get("assets", {})
                      set_multiline_output(f, "release_assets_include", assets.get("include", []))
                      set_multiline_output(f, "release_assets_exclude", assets.get("exclude", []))
                      f.write(get_output_line("check_runs-on", data["check"]["runs-on"]) + "\n")
                      f.write(get_output_line("check_run_script", data["check"]["run_script"]) + "\n")
                      f.write(get_output_line("check_features_cache_enable", data["check"]["features"]["cache"]["enable"]) + "\n")
                      f.write(get_output_line("check_features_cache_path", data["check"]["features"]["cache"]["path"]) + "\n")
                      f.write(get_output_line("check_features_cache_key_file", data["check"]["features"]["cache"]["key_file"]) + "\n")
                      f.write(get_output_line("build_runs-on", data["build"]["runs-on"]) + "\n")
                      f.write(get_output_line("build_run_script", data["build"]["run_script"]) + "\n")
                      f.write(get_output_line("build_features_cache_enable", data["build"]["features"]["cache"]["enable"]) + "\n")
                      f.write(get_output_line("build_features_cache_path", data["build"]["features"]["cache"]["path"]) + "\n")
                      f.write(get_output_line("build_features_cache_key_file", data["build"]["features"]["cache"]["key_file"]) + "\n")
    check:
        needs: parse_configs
        name: Check & Test
        runs-on: ${{ needs.parse_configs.outputs.check_runs_on }}
        strategy:
            matrix: ${{ fromJson(needs.parse_configs.outputs.check_matrix) }}
        steps:
            - uses: actions/checkout@v5
            - name: Cache dependencies
              if: needs.parse_configs.outputs.check_cache_enable == 'true'
              uses: actions/cache@v4
              with:
                  path: ${{ needs.parse_configs.outputs.check_cache_path }}
                  key: "${{ runner.os }}-pip-${{ hashFiles(needs.parse_configs.outputs.check_cache_key_file) }}"
            - name: Set up Python
              uses: actions/setup-python@v6
              with:
                  python-version: ${{ matrix.python-version }}
            - name: Make check script executable
              run: chmod +x ${{ needs.parse_configs.outputs.check_run_script }}
            - name: Run Check Script
              shell: bash
              run: ${{ needs.parse_configs.outputs.check_run_script }}
              env:
                  PYTHON_VERSION: ${{ matrix.python-version }}
                  RUNNER_OS: ${{ matrix.os }}
    approval:
        name: Approve for Release
        needs: [parse_configs, check]
        if: needs.parse_configs.outputs.skip_approval == 'false'
        runs-on: ubuntu-latest
        environment: release
        steps:
            - name: Manual approval step
              run: echo "Release approved. Proceeding to build."
    release:
        name: Build and Release
        needs: [parse_configs, approval]
        if: always() && (needs.parse_configs.outputs.skip_approval == 'true' || needs.approval.result == 'success')
        runs-on: ${{ needs.parse_configs.outputs.build_runs_on }}
        steps:
            - uses: actions/checkout@v5
              with:
                  fetch-depth: 0
            - name: Set up Python
              uses: actions/setup-python@v6
              with:
                  python-version: "3.12"
            - name: Install dependencies
              run: pip install toml pytz tomli
            - name: Cache dependencies
              if: needs.parse_configs.outputs.build_cache_enable == 'true'
              uses: actions/cache@v4
              with:
                  path: ${{ needs.parse_configs.outputs.build_cache_path }}
                  key: "${{ runner.os }}-pip-${{ hashFiles(needs.parse_configs.outputs.build_cache_key_file) }}"
            - name: Run Build Script for All Targets
              shell: bash
              run: |
                  chmod +x ${{ needs.parse_configs.outputs.build_run_script }}
                  for target in ${{ needs.parse_configs.outputs.build_targets }}; do
                    echo "--- Building for target: $target ---"
                    TARGET=$target ${{ needs.parse_configs.outputs.build_run_script }}
                  done
            - name: Prepare Release Assets
              id: prepare_assets
              shell: python
              run: |
                  import os
                  import sys
                  from pathlib import Path
                  # Add the toml library from the vendored location
                  sys.path.insert(0, str(Path(".github/vendored")))
                  import tomli
                  def get_asset_patterns(manifest_path: Path) -> tuple[list[str], list[str]]:
                      if not manifest_path.is_file():
                          print(f"Error: Manifest file not found at '{manifest_path}'", file=sys.stderr)
                          sys.exit(1)
                      try:
                          with open(manifest_path, "rb") as f:
                              manifest = tomli.load(f)
                          release_config = manifest.get("release", {})
                          assets_config = release_config.get("assets", {})
                          include_patterns = assets_config.get("include", [])
                          exclude_patterns = assets_config.get("exclude", [])
                          if not isinstance(include_patterns, list) or not isinstance(exclude_patterns, list):
                              print("Error: 'release.assets.include' and 'release.assets.exclude' must be arrays of strings.", file=sys.stderr)
                              sys.exit(1)
                          return include_patterns, exclude_patterns
                      except tomli.TOMLDecodeError:
                          print(f"Error: Could not decode TOML file at '{manifest_path}'", file=sys.stderr)
                          sys.exit(1)
                      except Exception as e:
                          print(f"An unexpected error occurred: {e}", file=sys.stderr)
                          sys.exit(1)
                  def find_files(root_dir: Path, include_patterns: list[str], exclude_patterns: list[str]) -> list[str]:
                      final_files = set()
                      for pattern in include_patterns:
                          for path in root_dir.glob(pattern):
                              if path.is_file():
                                  final_files.add(str(path))
                      excluded_files = set()
                      for pattern in exclude_patterns:
                          for path in root_dir.glob(pattern):
                              if path.is_file():
                                  excluded_files.add(str(path))
                      return sorted(list(final_files - excluded_files))
                  def main():
                      manifest_path = Path(".github/release-manifest.toml")
                      include, exclude = get_asset_patterns(manifest_path)
                      workspace_dir = Path(os.getcwd())
                      final_asset_list = find_files(workspace_dir, include, exclude)
                      with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                          f.write("final_assets<<EOF\n")
                          f.write("\n".join(final_asset_list))
                          f.write("\nEOF\n")
                  main()
            - name: Generate Release Notes
              id: notes_generator
              shell: python
              run: |
                  # -*- coding: utf-8 -*-
                  import os
                  import subprocess
                  import sys
                  from pathlib import Path
                  import toml
                  def get_previous_tag(strategy: str) -> str:
                      """
                      Determines the previous tag based on the provided strategy.
                      """
                      if strategy == "latest":
                          try:
                              command = "git describe --tags --abbrev=0"
                              result = subprocess.run(
                                  command,
                                  shell=True,
                                  check=True,
                                  capture_output=True,
                                  text=True,
                              )
                              return result.stdout.strip()
                          except subprocess.CalledProcessError as e:
                              print(f"Error finding latest tag: {e}", file=sys.stderr)
                              raise
                      else:
                          raise ValueError(f"Unsupported previous_tag_strategy: {strategy}")
                  def generate_changelog(previous_tag: str) -> str:
                      """
                      Generates a changelog from Git history between the previous tag and HEAD.
                      """
                      try:
                          command = f'git log {previous_tag}..HEAD --pretty=format:"- %s (%h)"'
                          result = subprocess.run(
                              command,
                              shell=True,
                              check=True,
                              capture_output=True,
                              text=True,
                          )
                          return result.stdout.strip()
                      except subprocess.CalledProcessError as e:
                          print(f"Error generating changelog: {e}", file=sys.stderr)
                          raise
                  def generate_assets_links(repo_full_name: str, tag: str, asset_files_str: str) -> str:
                      """
                      Generates a Markdown-formatted list of links for release assets.
                      """
                      if not asset_files_str:
                          return ""
                      asset_files = asset_files_str.strip().split("\n")
                      links = []
                      for asset_file in asset_files:
                          if not asset_file:
                              continue
                          filename = Path(asset_file).name
                          link = f"- [{filename}](https://github.com/{repo_full_name}/releases/download/{tag}/{filename})"
                          links.append(link)
                      return "\n".join(links)
                  def main():
                      """
                      Main function to generate and print release notes.
                      """
                      manifest_path = os.environ.get("MANIFEST_PATH")
                      if not manifest_path:
                          print("Error: Missing environment variable MANIFEST_PATH", file=sys.stderr)
                          sys.exit(1)
                      try:
                          repo = os.environ["GITHUB_REPOSITORY"]
                          tag = os.environ["INPUT_TAG"]
                          asset_files = os.environ.get("ASSET_FILES", "")
                          manifest = toml.load(manifest_path)
                          body_template = manifest["release"]["body_template"]
                          body = body_template.replace("{{tag}}", tag)
                          changelog_config = manifest["release"]["changelog"]
                          strategy = changelog_config.get("previous_tag_strategy", "latest")
                          previous_tag = get_previous_tag(strategy)
                          changelog_content = generate_changelog(previous_tag)
                          body = body.replace("{{changelog}}", changelog_content)
                          assets_links_content = generate_assets_links(repo, tag, asset_files)
                          body = body.replace("{{assets_links}}", assets_links_content)
                          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                              f.write("body<<EOF\n")
                              f.write(body)
                              f.write("\nEOF\n")
                      except KeyError as e:
                          print(f"Error: Missing environment variable {e}", file=sys.stderr)
                          sys.exit(1)
                      except FileNotFoundError:
                          print(f"Error: Manifest file not found at '{manifest_path}'", file=sys.stderr)
                          sys.exit(1)
                      except (subprocess.CalledProcessError, ValueError) as e:
                          print(f"An error occurred: {e}", file=sys.stderr)
                          sys.exit(1)
                  if __name__ == "__main__":
                      main()
              env:
                  GITHUB_REPOSITORY: ${{ github.repository }}
                  INPUT_TAG: ${{ github.event.inputs.tag }}
                  ASSET_FILES: ${{ steps.prepare_assets.outputs.final_assets }}
                  MANIFEST_PATH: ".github/release-manifest.toml"
            - name: Create Release
              uses: softprops/action-gh-release@v1
              with:
                  tag_name: ${{ github.event.inputs.tag }}
                  body: ${{ steps.notes_generator.outputs.body }}
                  files: ${{ steps.prepare_assets.outputs.final_assets }}
