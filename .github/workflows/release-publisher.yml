name: Release Publisher
on:
    workflow_dispatch:
        inputs:
            tag:
                description: "The tag to create the release for (e.g., v1.0.0)"
                required: true

permissions:
    contents: write
    id-token: write

jobs:
    parse_configs:
        name: Parse Configuration Files
        runs-on: ubuntu-latest
        outputs:
            # from actions-config.yml
            check_matrix: ${{ steps.yaml.outputs.check_matrix }}
            build_targets: ${{ steps.yaml.outputs.build_targets }}
            # from release-manifest.toml
            trigger_tag_pattern: ${{ steps.toml.outputs.trigger_tag_pattern }}
            skip_approval: ${{ steps.toml.outputs.release_skip_approval }}
            release_assets_include: ${{ steps.toml.outputs.release_assets_include }}
            release_assets_exclude: ${{ steps.toml.outputs.release_assets_exclude }}
            check_runs_on: ${{ steps.toml.outputs.check_runs-on }}
            check_run_script: ${{ steps.toml.outputs.check_run_script }}
            check_cache_enable: ${{ steps.toml.outputs.check_features_cache_enable }}
            check_cache_path: ${{ steps.toml.outputs.check_features_cache_path }}
            check_cache_key_file: ${{ steps.toml.outputs.check_features_cache_key_file }}
            build_runs_on: ${{ steps.toml.outputs.build_runs-on }}
            build_run_script: ${{ steps.toml.outputs.build_run_script }}
            build_cache_enable: ${{ steps.toml.outputs.build_features_cache_enable }}
            build_cache_path: ${{ steps.toml.outputs.build_features_cache_path }}
            build_cache_key_file: ${{ steps.toml.outputs.build_features_cache_key_file }}
        steps:
            - uses: actions/checkout@v5
            - name: Set up Python
              uses: actions/setup-python@v6
              with:
                  python-version: "3.12"
            - name: Install Python dependencies
              run: pip install PyYAML toml
            - name: Parse actions-config.yml
              id: yaml
              shell: python
              run: |
                  import yaml, json, os
                  with open('.github/actions-config.yml', 'r') as f:
                      data = yaml.safe_load(f)
                  check_matrix = json.dumps(data['check']['matrix'])
                  build_targets = " ".join(data['build']['matrix']['target'])
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write(f"check_matrix={check_matrix}\n")
                      f.write(f"build_targets={build_targets}\n")
            - name: Parse release-manifest.toml
              id: toml
              shell: python
              run: |
                  import toml, os
                  with open('.github/release-manifest.toml', 'r') as f:
                      data = toml.load(f)

                  def get_output_line(key, value):
                      if isinstance(value, bool):
                          value = str(value).lower()
                      return f"{key}={value}"

                  def set_multiline_output(f, key, value_list):
                      value = '\n'.join(value_list)
                      delimiter = 'GH_ACTIONS_EOF'
                      f.write(f"{key}<<{delimiter}\n")
                      f.write(f"{value}\n")
                      f.write(f"{delimiter}\n")

                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write(get_output_line('trigger_tag_pattern', data['trigger']['tag_pattern']) + '\n')
                      f.write(get_output_line('release_skip_approval', data['release']['skip_approval']) + '\n')
                      
                      assets = data.get('release', {}).get('assets', {})
                      set_multiline_output(f, 'release_assets_include', assets.get('include', []))
                      set_multiline_output(f, 'release_assets_exclude', assets.get('exclude', []))
                      
                      f.write(get_output_line('check_runs-on', data['check']['runs-on']) + '\n')
                      f.write(get_output_line('check_run_script', data['check']['run_script']) + '\n')
                      f.write(get_output_line('check_features_cache_enable', data['check']['features']['cache']['enable']) + '\n')
                      f.write(get_output_line('check_features_cache_path', data['check']['features']['cache']['path']) + '\n')
                      f.write(get_output_line('check_features_cache_key_file', data['check']['features']['cache']['key_file']) + '\n')
                      f.write(get_output_line('build_runs-on', data['build']['runs-on']) + '\n')
                      f.write(get_output_line('build_run_script', data['build']['run_script']) + '\n')
                      f.write(get_output_line('build_features_cache_enable', data['build']['features']['cache']['enable']) + '\n')
                      f.write(get_output_line('build_features_cache_path', data['build']['features']['cache']['path']) + '\n')
                      f.write(get_output_line('build_features_cache_key_file', data['build']['features']['cache']['key_file']) + '\n')

    check:
        needs: parse_configs
        name: Check & Test
        runs-on: ${{ needs.parse_configs.outputs.check_runs_on }}
        strategy:
            matrix: ${{ fromJson(needs.parse_configs.outputs.check_matrix) }}
        steps:
            - uses: actions/checkout@v5
            - name: Cache dependencies
              if: needs.parse_configs.outputs.check_cache_enable == 'true'
              uses: actions/cache@v4
              with:
                  path: ${{ needs.parse_configs.outputs.check_cache_path }}
                  key: "${{ runner.os }}-pip-${{ hashFiles(needs.parse_configs.outputs.check_cache_key_file) }}"
            - name: Set up Python
              uses: actions/setup-python@v6
              with:
                  python-version: ${{ matrix.python-version }}
            - name: Make check script executable
              run: chmod +x ${{ needs.parse_configs.outputs.check_run_script }}
            - name: Run Check Script
              shell: bash
              run: ${{ needs.parse_configs.outputs.check_run_script }}
              env:
                  PYTHON_VERSION: ${{ matrix.python-version }}
                  RUNNER_OS: ${{ matrix.os }}

    approval:
        name: Approve for Release
        needs: [parse_configs, check]
        if: needs.parse_configs.outputs.skip_approval == 'false'
        runs-on: ubuntu-latest
        environment: release
        steps:
            - name: Manual approval step
              run: echo "Release approved. Proceeding to build."

    release:
        name: Build and Release
        needs: [parse_configs, approval]
        if: always() && (needs.parse_configs.outputs.skip_approval == 'true' || needs.approval.result == 'success')
        runs-on: ${{ needs.parse_configs.outputs.build_runs_on }}
        steps:
            - uses: actions/checkout@v5
              with:
                  fetch-depth: 0
            - name: Check if tag exists
              shell: bash
              run: |
                  if git rev-parse "refs/tags/${{ github.event.inputs.tag }}" >/dev/null 2>&1; then
                    echo "Error: Tag '${{ github.event.inputs.tag }}' already exists."
                    exit 1
                  fi
            - name: Set up Python
              uses: actions/setup-python@v6
              with:
                  python-version: "3.12"
            - name: Install dependencies
              run: pip install toml pytz tomli
            - name: Cache dependencies
              if: needs.parse_configs.outputs.build_cache_enable == 'true'
              uses: actions/cache@v4
              with:
                  path: ${{ needs.parse_configs.outputs.build_cache_path }}
                  key: "${{ runner.os }}-pip-${{ hashFiles(needs.parse_configs.outputs.build_cache_key_file) }}"
            - name: Run Build Script for All Targets
              shell: bash
              run: |
                  chmod +x ${{ needs.parse_configs.outputs.build_run_script }}
                  for target in ${{ needs.parse_configs.outputs.build_targets }}; do
                    echo "--- Building for target: $target ---"
                    TARGET=$target ${{ needs.parse_configs.outputs.build_run_script }}
                  done
            - name: Prepare Release Assets
              id: prepare_assets
              shell: python
              run: |
                  import os
                  import sys
                  from pathlib import Path
                  # Add the toml library from the vendored location
                  sys.path.insert(0, str(Path(".github/vendored")))
                  import tomli

                  def get_asset_patterns(manifest_path: Path) -> tuple[list[str], list[str]]:
                      if not manifest_path.is_file():
                          print(f"Error: Manifest file not found at '{manifest_path}'", file=sys.stderr)
                          sys.exit(1)
                      try:
                          with open(manifest_path, "rb") as f:
                              manifest = tomli.load(f)
                          release_config = manifest.get("release", {})
                          assets_config = release_config.get("assets", {})
                          include_patterns = assets_config.get("include", [])
                          exclude_patterns = assets_config.get("exclude", [])
                          if not isinstance(include_patterns, list) or not isinstance(exclude_patterns, list):
                              print("Error: 'release.assets.include' and 'release.assets.exclude' must be arrays of strings.", file=sys.stderr)
                              sys.exit(1)
                          return include_patterns, exclude_patterns
                      except tomli.TOMLDecodeError:
                          print(f"Error: Could not decode TOML file at '{manifest_path}'", file=sys.stderr)
                          sys.exit(1)
                      except Exception as e:
                          print(f"An unexpected error occurred: {e}", file=sys.stderr)
                          sys.exit(1)

                  def find_files(root_dir: Path, include_patterns: list[str], exclude_patterns: list[str]) -> list[str]:
                      final_files = set()
                      for pattern in include_patterns:
                          for path in root_dir.glob(pattern):
                              if path.is_file():
                                  final_files.add(str(path))
                      excluded_files = set()
                      for pattern in exclude_patterns:
                          for path in root_dir.glob(pattern):
                              if path.is_file():
                                  excluded_files.add(str(path))
                      return sorted(list(final_files - excluded_files))

                  def main():
                      manifest_path = Path(".github/release-manifest.toml")
                      include, exclude = get_asset_patterns(manifest_path)
                      workspace_dir = Path(os.getcwd())
                      final_asset_list = find_files(workspace_dir, include, exclude)
                      with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                          f.write("final_assets<<EOF\n")
                          f.write("\n".join(final_asset_list))
                          f.write("\nEOF\n")
                  main()
            - name: Generate Release Notes
              id: notes_generator
              shell: python
              run: |
                  """
                  Dynamically generates release notes based on a TOML manifest and git history.

                  This script is designed to be called from a GitHub Actions workflow. It reads
                  a manifest file, gathers information from environment variables and git,
                  replaces placeholders in a template, and prints the final release notes
                  body to stdout.
                  """

                  import os
                  import shutil
                  import subprocess
                  import sys
                  from datetime import datetime, timedelta, timezone
                  from pathlib import Path

                  try:
                      import toml
                  except ImportError:
                      print("Error: 'toml' package is not installed. Please run 'pip install toml'", file=sys.stderr)
                      sys.exit(1)


                  def get_git_changelog(config: dict, current_tag: str) -> str:
                      """
                      Generates a changelog by comparing the current tag with the previous one.

                      Args:
                          config: The 'release.changelog' section of the manifest.
                          current_tag: The current git tag (GITHUB_REF_NAME).

                      Returns:
                          A formatted string of commit messages, or a default message if no
                          changes are found or an error occurs.
                      """
                      git_executable = shutil.which("git")
                      if not git_executable:
                          raise RuntimeError("git executable not found in PATH")

                      try:
                          # Get all tags sorted by version descending
                          tags_result = subprocess.run([git_executable, "tag", "--sort=-v:refname"], capture_output=True, text=True, check=True, encoding="utf-8")  # noqa: S603
                          tags = tags_result.stdout.strip().split("\n")

                          previous_tag = None
                          if current_tag in tags:
                              try:
                                  current_index = tags.index(current_tag)
                                  if current_index + 1 < len(tags):
                                      previous_tag = tags[current_index + 1]
                              except (ValueError, IndexError):
                                  pass  # Should not happen if tag is in list

                          # Define the pretty format for git log
                          log_format = "- %s (%h)"

                          # Determine the git log command based on previous_tag
                          if previous_tag:
                              diff_method = config.get("diff_method", "..")
                              if diff_method not in ["..", "..."]:
                                  diff_method = ".."

                              command = [git_executable, "log", f"--pretty=format:{log_format}", f"{previous_tag}{diff_method}{current_tag}"]
                          else:
                              # First release, get all logs up to the current tag
                              command = [git_executable, "log", f"--pretty=format:{log_format}", current_tag]

                          # We trust the tag names from the GitHub environment not to contain malicious shell characters.
                          # The arguments are passed as a list, which prevents shell injection.
                          changelog_result = subprocess.run(command, capture_output=True, text=True, check=True, encoding="utf-8")  # noqa: S603

                          changelog = changelog_result.stdout.strip()
                          return changelog if changelog else "No changes in this release."

                      except (subprocess.CalledProcessError, FileNotFoundError) as e:
                          print(f"Warning: Git command failed: {e}", file=sys.stderr)
                          return "No changes in this release."


                  def get_release_date(config: dict) -> str:
                      """
                      Generates a formatted, timezone-aware release date string.

                      Args:
                          config: The 'release.date' section of the manifest.

                      Returns:
                          An ISO 8601 formatted date string, enclosed in backticks.
                      """
                      tz_str = config.get("timezone", "+00:00")
                      try:
                          sign = -1 if "-" in tz_str else 1
                          hours, minutes = map(int, tz_str.replace("+", "").replace("-", "").split(":"))
                          tz_offset = timedelta(hours=hours, minutes=minutes) * sign
                          tz = timezone(tz_offset)
                      except Exception:
                          tz = timezone.utc

                      now = datetime.now(timezone.utc).astimezone(tz)
                      # Format to ISO 8601 with 6 digits for microseconds
                      iso_date = now.isoformat(timespec="microseconds")
                      return f"`{iso_date}`"


                  def main():
                      """
                      Main function to generate and print release notes.
                      """
                      # 1. Read environment variables
                      github_repo = os.getenv("GITHUB_REPOSITORY")
                      current_tag = os.getenv("GITHUB_REF_NAME")
                      manifest_path_str = os.getenv("MANIFEST_PATH")

                      if not github_repo:
                          print("Error: Missing GITHUB_REPOSITORY environment variable.", file=sys.stderr)
                          sys.exit(1)
                      if not current_tag:
                          print("Error: Missing GITHUB_REF_NAME environment variable.", file=sys.stderr)
                          sys.exit(1)
                      if not manifest_path_str:
                          print("Error: Missing MANIFEST_PATH environment variable.", file=sys.stderr)
                          sys.exit(1)

                      try:
                          owner, repo_name = github_repo.split("/")
                      except ValueError:
                          print(f"Error: Invalid GITHUB_REPOSITORY format: {github_repo}", file=sys.stderr)
                          sys.exit(1)

                      # 2. Read and parse the manifest file
                      manifest_path = Path(manifest_path_str)
                      if not manifest_path.is_file():
                          print(f"Error: Manifest file not found at '{manifest_path_str}'", file=sys.stderr)
                          sys.exit(1)

                      manifest = toml.load(manifest_path)
                      release_config = manifest.get("release", {})
                      body_template = release_config.get("body_template", "")

                      # 3. Prepare variables for substitution
                      changelog_config = release_config.get("changelog", {})
                      contributors_config = release_config.get("contributors", {})
                      assets_config = release_config.get("assets", {})
                      date_config = release_config.get("date", {})

                      # Handle contributors template
                      contributors_template = contributors_config.get("template", "")
                      contributors = contributors_template.replace("{{owner}}", owner).replace("{{repo_name}}", repo_name)

                      # Handle assets links
                      assets_links = ""
                      asset_file_name = assets_config.get("associate", {}).get("assets_links")
                      if asset_file_name:
                          asset_path = manifest_path.parent / asset_file_name
                          if asset_path.is_file():
                              assets_links = asset_path.read_text(encoding="utf-8")

                      # 4. Perform all substitutions
                      replacements = {
                          "{{tag}}": current_tag,
                          "{{repo_name}}": repo_name,
                          "{{owner}}": owner,
                          "{{changelog}}": get_git_changelog(changelog_config, current_tag),
                          "{{contributors}}": contributors,
                          "{{assets_links}}": assets_links,
                          "{{release_date}}": get_release_date(date_config),
                      }

                      final_body = body_template
                      for placeholder, value in replacements.items():
                          final_body = final_body.replace(placeholder, value)

                      # 5. Write final body to GITHUB_OUTPUT
                      with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                          f.write("body<<EOF\n")
                          f.write(final_body)
                          f.write("\nEOF\n")


                  if __name__ == "__main__":
                      main()
              env:
                  GITHUB_REPOSITORY: ${{ github.repository }}
                  GITHUB_REF_NAME: ${{ github.ref_name }}
                  MANIFEST_PATH: ".github/release-manifest.toml"
            - name: Create Release
              uses: softprops/action-gh-release@v1
              with:
                  tag_name: ${{ github.event.inputs.tag }}
                  body: ${{ steps.notes_generator.outputs.body }}
                  files: ${{ steps.prepare_assets.outputs.final_assets }}
